---
title: shell如何解析命令以及eval命令
p: shell/cmdline_parse.md
date: 2019-07-06 18:20:43
tags: Shell
categories: Shell
---

--------

**[Linux基础系列文章大纲](/linux/index)**  
**[Shell系列文章大纲](/shell/index)**

--------

<a name="blog1"></a>
# shell解析命令行

shell读取和执行命令时的大致操作过程：

![](/img/shell/733013-20190706104530258-909599237.jpg)

以执行以下命令为例：
```
echo -e "some files:" ~/i* "\nThe date:$(date +%F)\n$name's age is $((a+4))" >/tmp/a.log
```
假设在执行该命令前，已赋值变量`name=longshuai`和`a=24`，于是重定向到/tmp/a.log中的结果为：
```
some files: /root/inotify.sh /root/inotify.sh.ori 
The date:2017-08-14
longshuai's age is 28
```
**1.读取输入的命令行。**  

**2.解析引用并分割命令行为各个单词，各单词称为token。其中重定向所在的token会被保存下来，直到扩展步骤(5)结束后才进行相关处理，如进行扩展、截断文件等。**

shell中有3种引用方式：  
- 反斜线转义：使得元字符变为普通的字面字符。但这只能对反斜线后一个字符进行转义。  
- 单引号引用：单引号内的所有字符全部变为字面符号符号。但注意：单引号内不能再使用单引号，即使使用了反斜线转义也不允许。  
- 双引号引用：使双引号内所有字符变为字面符号，但"\"、"$"、"`"(反引号)除外，如果开启了"!"引用历史命令时，则感叹号也除外。  

解析引用后，于是就可以将命令行进行单词分割，分割后的每一部分都称为一个token。分隔时，不仅分割单个命令，还分割命令列表，所以分隔符包括bash的元字符以及bash中的控制符号，即：空格、制表符、分号、管道符号、&、&&、;;、||、重定向符号、圆括号以及意味着命令终止的换行符。
于是上述命令分割为以下几个token：

![](/img/shell/733013-20190706104524565-764186274.jpg)

（注：虽然换行符是shell划分命令行token的元字符，但是shell并不认识这里的\n，shell只认识我们直接手动敲下的回车键，而这里\n是由echo -e选项识别的换行符，因此这里的\n不是shell解析命令行时划分token的换行符，于是\n也被认为是双引号包围的token的一部分）

如果分割时发现了管道符号，或者是命令列表等组合了多个命令的情况，则每个命令都的token都相互独立。

![](/img/referer.jpg)

**3.检查命令行结构。主要检查是否有命令列表、是否有shell编程结构的命令，如if判断命令、循环结构的for/while/select/until，这些命令属于保留关键字，需要特殊处理。**

**4.对第一个token进行别名扩展。如果检查出它是别名，则扩展后回到(2)再次进行token分解过程。如果检查出它是函数，则执行函数体中的复合命令。如果它既是别名，又是函数(即命令别名和函数同名称的情况)，则优先执行别名。在概念上，别名的临时性最强，优先级最高。**

**5.进行各种扩展。扩展顺序为：大括号扩展；波浪号扩展；参数、变量、算术扩展和命令替换，如果系统支持，此步还进行进程替换；单词拆分；文件名扩展。**

**不同引号的引用方式，将改变扩展的起始步骤**，正如上图所画，没有任何引号时将从头到尾全部扩展，使用单引号时将完全不会进行任何扩展，使用双引号时将从变量替换开始继续扩展。

- (1).大括号扩展：如/tmp/{a,b}.log扩展为/tmp/a.log和/tmp/b.log。  

- (2).波浪号扩展：扩展为家目录。如root用户下的~/.ssh扩展为/root/.ssh。  

- (3).变量扩展：即操作和替换变量值。如$a替换为它的值24，`${name:-longshuai}`替换为longshuai。  

- (4).算术扩展：计算算术值，并将计算结果替换到对应位置处。例如`$((a+4))`替换为28。  

- (5).命令替换：此过程将执行命令替换中的命令，并将结果替换到token的对应位置处。  

- (6).进程替换：将进程的执行结果替换到对应位置。类似于命令替换。替换格式为`<(cmd_list)`和`>(cmd_list)`，例如`cat <(cat /etc/hosts)`。redhat系列应该都支持进程替换。  
  经过以上几种扩展后，得到如下结果  

  ![](/img/shell/733013-20190706104518732-1018199079.jpg)

- (7).单词拆分：扫描变量扩展、命令替换和算术扩展的结果，对非引号内的结果按照`$IFS`的值对这些结果进行单词分割。  
  注意，如果没有进行扩展，或者扩展结果使用引号包围了，则不会进行此步的单词拆分。
  默认情况下，`$IFS`值为` \t\n`，所以扩展结果中每遇到空格、制表符、换行符都将被分割为两个单词。  
  这一步其实很容易犯错，典型的是test命令。例如变量`name="Ma longshuai"`，则`test $name == "longshuai"`将报错，因为变量扩展后该语句变为`test Ma longshuai == "longshuai"`，由于是变量替换，所以随后进行单词拆分，使得Ma和longshuai被拆分为两个单词，但实际上它们共同组成变量name的值。  
  所以，为了正确操作变量替换和命令替换，尽量将它们使用引号包围。例如`test "$name" == "longshuai"`，这时将不会进行单词拆分。  

- (8).文件名扩展：对每个token进行搜索，将搜索`*`、`?`和`[`符号，搜索到了将进行文件名扩展。例如将上面的`/root/i*`扩展为`/root/inotify.sh /root/inotify.sh.ori`。  

**6.引号去除。经过上面的过程，该扩展的都扩展了，不需要的引号在此步就可以去掉了。**

所以得到如下结果。

![](/img/shell/733013-20190706104508458-1951439576.jpg)

**7.搜索和执行命令。**

单词分割后，复杂的命令行将由各个简单命令结构组成。于是可以搜索每个简单命令结构的第一个token中的命令，同时还带有一系列命令选项。例如上面的"echo"和"-e"。

如果命令中不含任何斜杠：  
- (1).则先判断是否有此名称的shell function存在，如果有则调用它，否则进行下一步搜索。  
- (2).判断该命令是否为bash内置命令，如果是则执行它，否则进行下一步搜索。  
- (3).从$PATH的路径下搜索该命令，如果搜索到了，则执行，否则报错。  

如果命令中包含一个或多个斜杠，则进行相对路径扩展、绝对路径查找，找到了则执行，否则报错。

**8.返回退出状态码。**

![](/img/referer.jpg)

<a name="blog2"></a>
# eval命令

正常情况下，当搜索到命令时将会执行命令，但如果搜索到的命令为eval时，则处理方式有所不同。

它的语法格式为：

> eval command arguments

按照前文所述shell解析过程，将最终得到`eval command`和一系列扩展后的选项、参数，当搜索命令时，搜索到的结果为eval命令，于是eval命令将除了eval命令(以及eval的选项)的所有token再次传递给shell进行二次解析。但重定向所在token除外，因为重定向token早已被shell保存下来，所以不会再次截断文件。

也就是说，`command arguments`被当作eval命令的参数，被传递给shell进行解析、执行。

执行过程如下图所示：

![](/img/shell/733013-20190706104502807-400120578.jpg)

使用示例来说明：
```
[root@xuexi ~]# a=24;name='long$a'   # 注意，使用的是单引号，禁止$a被扩展
```
如果直接执行`echo $name`，则结果为"long$a"，但如果执行`eval echo $name`，结果将是"long24"。
```
[root@xuexi ~]# eval echo $name
long24
```
首先shell按照正常过程解析，在变量替换时由于使用了单引号，所以$name第一次变量替换的结果为"long$a"，直到命令搜索时发现搜索到的命令是eval命令，执行eval命令，该命令将其参数`echo long$a`再次传递给shell，相当于在标准输入中输入了`echo long$a`，于是shell进行二次解析，这次的变量替换将$a替换为24，最后搜索命令发现是echo命令，于是最终得到"long24"。

关于eval，更多的用法是间接变量`$$var`的用法，在bash shell中需要在第一个$前加上反斜线，即`\$$var`，这么做的原因是显然的：防止第一次shell解析时被当作特殊变量`$$`被扩展。
```
[root@xuexi ~]# a=b
[root@xuexi ~]# b=haha
[root@xuexi ~]# eval echo \$$a
haha
```

注：本文并非一定准确，只是根据man bash总结而来。如有错误，请明确指出。多谢！







