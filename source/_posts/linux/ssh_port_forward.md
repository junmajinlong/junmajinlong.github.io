---
title: ssh端口转发
p: linux/ssh_port_forward.md
date: 2021-03-15 14:17:18
tags: Linux
categories: Linux
---

------

**[Linux基础系列文章大纲](/linux/index)**  
**[Shell系列文章大纲](/shell/index)**  

SSH系列文章：  
[SSH基础：SSH和SSH服务](/linux/ssh)  
[SSH转发代理：ssh-agent用法详解](/linux/ssh_agent)  
[SSH隧道：端口转发功能详解](/ssh_port_forward)  

------



# ssh端口转发

ssh转发分为本地端口转发、远程端口转发和动态端口转发。

## ssh安全隧道(一)：本地端口转发

如下图，假如host3和host1、host2都同互相通信，但是host1和host2之间不能通信，如何从host1连接上host2？

对于实现ssh连接来说，实现方式很简单，从host1 ssh到host3，再ssh到host2，也就是将host3作为跳板的方式。但是如果不是ssh，而是http的80端口呢？如何让host1能访问host2的80端口？

![](/img/linux/733013-20170706232458456-281342448.png)

ssh支持本地端口转发，语法格式为：
```
ssh -L [local_bind_addr:]local_port:remote:remote_port middle_host
```
以上图为例，实现方式是在host1上执行：
```
[root@xuexi ~]# ssh -g -L 2222:host2:80 host3
```

其中"-L"选项表示本地端口转发，其工作方式为：在本地指定一个由ssh监听的转发端口(2222)，将远程主机的端口(`host2:80`)映射为本地端口(2222)，当有主机连接本地映射端口(2222)时，本地ssh就将此端口的数据包转发给中间主机(host3)，然后host3再与远程主机的端口(`host2:80`)通信。

现在就可以通过访问host1的2222端口来达到访问`host2:80`的目的了。例如：

![](/img/linux/733013-20170706232528378-580268209.png)

再来解释下"-g"选项，指定该选项表示允许外界主机连接本地转发端口(2222)，如果不指定"-g"，则host4将无法通过访问`host1:2222`达到访问`host2:80`的目的。甚至，host1自身也不能使用`172.16.10.5:2222`，而只能使用`localhost:2222`或`127.0.0.1:2222`这样的方式达到访问`host2:80`的目的，之所以如此，是因为本地转发端口默认绑定在回环地址上。可以使用bind_addr来改变转发端口的绑定地址，例如：
```
[root@xuexi ~]# ssh -L 172.16.10.5:2222:host2:80 host3
```
这样，host1自身就能通过访问`172.16.10.5:2222`的方式达到访问`host2:80`的目的。

一般来说，使用转发端口，都建议同时使用"-g"选项，否则将只有自身能访问转发端口。

再来分析下转发端口通信的过程。

![](/img/linux/733013-20170706232654237-1722009435.png)

当host4发起`172.16.10.5:2222`的连接时(即步骤①)，数据包的目标地址和端口为`172.16.10.5:2222`。由于host1上ssh已经监听了2222端口，并且知道该端口映射自哪台主机哪个端口，所以将会把该数据包目标地址和端口替换为`172.16.10.3:80`，并将此数据包通过转发给host3。当host3收到该数据包时，发现是host1转发过来请求访问host2:80的数据包，所以host3将代为访问host2的80端口。

**所以，host1和host3之间的通信方式是SSH协议，这段连接是安全加密的，因此称为"安全隧道"，而host3和host2之间通信协议则是HTTP而不是ssh**。

现在再来考虑下，通过本地端口转发的方式如何实现ssh跳板的功能呢？仍以上图为例：
```
[root@xuexi ~]# ssh -g -L 22333:host2:22 host3]
```
这样只需使用ssh连上host1的22333端口就等于连接了host2的22端口。

最后，关于端口转发有一个需要注意的问题：ssh命令中带有要执行的命令。考虑了下面的三条在host1上执行的命令的区别。
```
[root@xuexi ~]# ssh -g -L 22333:host2:22 host3
[root@xuexi ~]# ssh -g -L 22333:host2:22 host3 "ifconfig"
[root@xuexi ~]# ssh -g -L 22333:host2:22 host3 "sleep 10"
```
第一条命令开启了本地端口转发，且是以登录到host3的方式开启的，所以执行完该命令后，将跳到host3主机上，当退出host3时，端口转发功能将被关闭。另外，host1上之所以要开启端口转发，目的是为了与host2进行通信，而不是跳到host3上，所以应该在ssh命令行上加上"-f"选项让ssh在本机host1上以后台方式提供端口转发功能，而不是跳到host3上来提供端口转发功能。

第二条命令在开启本地转发的时候还指定了要在**host3**上执行`ifconfig`命令，但是ssh的工作机制是远程命令执行完毕的那一刻，ssh关闭连接，所以此命令开启的本地端口转发功能有效期只有执行`ifconfig`命令的一瞬间。

第三条命令和第二条命令类似，只不过指定的是睡眠10秒命令，所以此命令开启的本地转发功能有效期只有10秒。

结合上面的分析，开启端口转发功能时，建议让ssh以后台方式提供端口转发功能，且明确指示不要执行任何ssh命令行上的远程命令。即最佳开启方式为：
```
[root@xuexi ~]# ssh -f -N -g -L 22333:host2:22 host3
```
## ssh安全隧道(二)：远程端口转发

ssh除了支持本地端口转发，还支持远程端口转发。顾名思义，远程端口转发表示的是将远程端口的数据转发到本地。

如下图：假如host3是内网主机，它能和host2互相通信，也能和host1通信，但反过来，host1不能和host3通信。这时要让host1访问host3或host2就没办法通过本地端口转发了，因为要在host1上开启本地端口转发，必须要和host3通信请求建立隧道。

![](/img/linux/733013-20170706232859284-1595079781.png)

可以通过在**host3**上发起远程端口转发来实现，因为host3能和host1通信，host3可以请求在host1和host3之间建立隧道。

语法如下：
```
ssh -R [bind_addr:]remote1_port:host:port remote1
```
以上图为例，实现方式是在**host3**上执行：
```
[root@xuexi ~]# ssh -R 22333:host2:80 host1
```
这表示host3请求host1上的sshd服务，在**host1**上建立一个套接字监听22333端口，它是host2端口的映射，当有主机连接`host1:22333`时，此连接中的数据全部都通过**host1和host3之间的安全隧道**转发给host3，再由host3向host2的80端口发起访问。由于host3请求开启的转发端口是在远程主机host1上的，所以称为"远程端口转发"。

再考虑下面这条命令所开启的远程转发端口，它是在host3上执行的。
```
[root@xuexi ~]# ssh -R 22333:host3:80 host1
```
该命令将自身的`host3:80`映射到`host1:22333`上，这也能让host1和host2、host3通信，因为隧道是建立在`host1:22333<-->host3:80`上的。

但是，远程端口转发和本地端口转发最大的一个区别是，远程转发端口是由host1上的sshd服务控制的，**默认配置情况下，sshd服务只允许本地开启的远程转发端口(22333)绑定在环回地址(127.0.0.1)上**，即使显式指定了bind_addr也无法覆盖。例如：
```
[root@xuexi ~]# ssh -R *:22333:host2:80 host1 

[root@xuexi ~]# netstat -tnlp
Active Internet connections (only servers)
tcp   0   0 0.0.0.0:22        0.0.0.0:*   LISTEN  8405/sshd  
tcp   0   0 127.0.0.1:25      0.0.0.0:*   LISTEN  1422/master
tcp   0   0 127.0.0.1:22333   0.0.0.0:*   LISTEN  8407/sshd  
tcp   0   0 :::22             :::*        LISTEN  8405/sshd  
tcp   0   0 ::1:25            :::*        LISTEN  1422/master
tcp   0   0 ::1:22333         :::*        LISTEN  8407/sshd
```

**要允许本地的远程转发端口绑定在非环回地址上，需要在host1的sshd配置文件中启用"GatewayPorts"项**，它的默认值为no。启动该选项后，不给定`bind_addr`或`bind_addr`设置为`*`都表示绑定在所有地址上。如下：

```
[root@xuexi ~]# ssh -g -R *:22333:host2:80 host1

[root@xuexi ~]# netstat -tnlp
Active Internet connections (only servers)
tcp   0  0 0.0.0.0:22      0.0.0.0:*   LISTEN  8466/sshd  
tcp   0  0 127.0.0.1:25    0.0.0.0:*   LISTEN  1422/master
tcp   0  0 0.0.0.0:22333   0.0.0.0:*   LISTEN  8468/sshd  
tcp   0  0 :::22           :::*        LISTEN  8466/sshd  
tcp   0  0 ::1:25          :::*        LISTEN  1422/master
tcp   0  0 :::22333        :::*        LISTEN  8468/sshd
```
和前面的本地转发端口一样，建议的几个选项是："-g"、"-f"、"-N"。即推荐的命令写法是：
```
[root@xuexi ~]# ssh -fgN -R 22333:host2:80 host1
```
现在，就可以通过访问`host1:22333`达到访问`host2:80`的目的了。如下图所示。

![](/img/linux/733013-20170706233029753-823451442.png)

## ssh安全隧道(三)：动态端口转发(SOCKS代理)

无论是本地端口转发还是远程端口转发，都是将某固定主机及其端口映射到本地或远程转发端口上，例如将host2:80映射到`host1:2222`。也就是说，本地或远程转发端口和目标端口所代表的应用层协议是一对一的关系，2222端口必须对应的是http的80端口，使用浏览器向`host1:2222`端口发起http请求当然没问题，但是使用ssh工具向`host1:2222`发起连接将会被拒绝，因为host2上http服务只能解析http请求，不能解析ssh连接请求。

ssh支持动态端口转发，由ssh来判断发起请求的工具使用的是什么应用层协议，然后根据判断出的协议结果决定目标端口。
以下图为例进行说明，host1处在办公内网，能和host3互相通信，但它无法直接和互联网和host2通信，而host3则可以和host2以及互联网通信。

![](/img/linux/733013-20170706233246425-1384840260.png)

要让host1访问互联网，又能和host2的22端口即ssh服务通信，显然在host1上仅设置一个本地端口转发是不够的，虽然可以设置多个本地转发端口分别映射不同的端口，但这显然比较笨重和麻烦。使用动态端口转发即可。

语法格式为：
```
ssh -D [bind_addr:]port remote 
```
以上图为例，在host1上执行：
```
[root@xuexi ~]# ssh -Nfg -D 2222 host3
```
执行完上面的命令，host1将在本地开启SOCKS4或SOCKS5服务来监听2222端口。只要客户端程序工具(隐含了使用的应用层协议类型)将其自身的代理设置为`host1:2222`，则该程序所有产生的数据都将转发到`host1:2222`，再由`host1:2222`将数据通过隧道转发给host3，最后由host3和互联网或host2上对应客户端工具的应用层协议的端口进行通信。

其实很简单，假如host4使用IE浏览器作为客户端工具，并将IE浏览器的代理设置为`host1:2222`，由于IE浏览器发起的请求使用的是http协议(此处不考虑其他可能的协议)，那么IE浏览器产生的数据都转发到`host1:2222`，再由`host1:2222`通过隧道转发给host3，host3能联网，所以host4就实现了联网功能。如下图设置：

![](/img/linux/733013-20170706233319503-828779612.png)

再比如host4上的QQ客户端也可以设置代理。这样QQ产生的数据都将通过`host1:2222`转发出去，`host1:2222`再将QQ的数据转发到host3上，host3知道这些数据使用的协议是oicq，所以host3会去连接腾讯的QQ服务器(oicq服务对应的端口)。

![](/img/linux/733013-20170706233340128-465435728.png)

ssh只支持socks4和socks5两种代理，有些客户端工具中需要明确指明代理类型。

和本地、远程端口转发一样，建议的选项是："-f"、"-N"和"-g"。

由于ssh动态端口转发是ssh客户端的功能，所以不使用ssh命令，使用SecurtCRT、putty等ssh客户端工具都可以实现代理上网。例如，本地主机不能上网，但能和172.16.10.6的SSH服务通信，而172.16.10.6能上网，则可以在本地主机先使用SecurtCRT连接172.16.10.6，再在对应的会话选项上做如下设置，使得本地主机也能上网。(注意：我没说可以那啥啊，好公民不那啥！！！)

![](/img/linux/733013-20170706233416769-1270249309.png)

然后，在本地主机查看下是否监听了SecurtCRT中指定的8888动态转发端口。

![](/img/linux/733013-20170706233429190-1120145425.png)

现在，本机所有数据包都通过SecurtCRT所连接的172.16.10.6流向外界。