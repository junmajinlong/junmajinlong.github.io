---
title: 操作系统修炼秘籍（6）：系统调用
p: os/syscalls.md
date: 2019-10-11 13:20:41
tags: OS
categories: OS
---


-----------

**[点我查看操作系统秘籍连载](https://www.junmajinlong.com/os/index/)**

-----------


## 操作系统的服务端口：系统调用

用户进程工作在用户态，它是受限的，很多涉及到硬件的操作都无法执行，但是它们又想要取得结果，就只能请求工作在内核态的操作系统帮助完成这些操作，并将操作结果交给用户进程。

**系统调用**（system call）就是操作系统提供给用户进程请求操作系统做一些特权操作的接口，即为用户进程提供服务的窗口。在Linux下可以通过`man syscalls`命令查看Linux提供的所有系统调用。

理解系统调用其实很简单，比如有一个程序想要读取a.log文件（例如`head -n 1 a.log`），读取之前必须先打开文件，但是用户进程是没有权限打开文件的，所以用户进程只能发送一个open()的系统调用请求操作系统去帮忙打开这个文件，操作系统打开这个文件后会将打开的结果——文件描述符交给用户进程，用户进程通过这个文件描述符就能去操作这个文件。再进一步，用户进程想要从这个打开的文件中读取一行数据，用户进程是没有权限读取文件的，只能发送一个read()系统调用请求操作系统去读取这一行数据，操作系统读取这行数据后就能交给用户进程。

不难发现，系统调用open()和read()都像是函数。其实它们确实都是函数，只不过是比较特殊的由操作系统提供的，一般是由汇编语言编写或参杂了部分汇编代码，因为它们要和硬件交互。

![](/img/os/733013-20191011130708645-549114419.jpg)


对于非C程序，其实本质还是一样的。比如CPython，也有open()函数，它是对C库函数open()的再次封装。所以，在Python程序中调用open()方法打开文件，其实是调用C库的open()函数，再通过open()库函数发起系统调用请求操作系统打开文件，并将结果交给Python程序。

最后，结合前面介绍的中断概念，描述下发起系统调用后的主要过程：  
1. 发起系统调用，请求操作系统帮忙执行某些操作，这会产生软中断；  
2. 软中断导致陷入内核，CPU控制权交给操作系统，操作系统处理中断，即执行被请求的操作；  
3. 如果一切正常，操作系统在完成操作后会恢复到断点处继续向下执行，这会回到用户态；  
4. 用户进程取得操作系统操作的成果，继续向下执行。  
