---
title: Ruby语法杂项
p: ruby/ruby_start.md
date: 2020-05-11 09:37:29
tags: Ruby
categories: Ruby
---

------

**[回到Ruby系列文章](/ruby/index/)**

------

# Ruby杂项

- **Ruby是纯正血统的面向对象语言，所有的一切，一切的一切都是对象**
- **Ruby里块(语句块)的特性非常重要，这个优美的特性贯穿整个Ruby**
- **Ruby里模块和类的概念一样重要，模块也是Ruby里的一个非常优美的特性**
- **变量命名惯例**
  - 局部变量、方法参数、方法的名称都使用小写字母开头
    -   有时候变量、方法以下划线开头`_name`也是局部的意思，它表示这是私有的东西，不应该暴露给外界
  - 全局变量以`$`开头，例如`$var`
  - 实例变量以`@`开头，例如`@name`
  - 类变量以`@@`开头，例如`@@class_var`
  - 类名称、模块名称、常量名称都以大写字母开头
  - 方法名称可以以`?、!、=`字符结尾，例如`equals?`
    - `?`字符结尾的方法，表示返回的是一个布尔值，用于测试true/false
    - `!`字符结尾的方法，表示警告提醒，这类方法原处修改(destructive)对象，要小心使用。一般都会提供成对的带有`!`结尾和不带`!`结尾(non-destructive)的方法供选择。例如`uniq()`和`uniq!()`，前者修改的是拷贝后的对象，后者在原有对象上修改
    - `=`结尾的方法表示赋值行为，例如有一个方法名为`test=()`，那么`test=(6)`等价于`test = 6`。正如数组元素赋值`arr[1] = 3`实际上是调用了`[]=()`这个方法，它等价于`arr[1]=(3)`或`arr[1]= 3`。所以，对于面向对象来说，它表现的是setter类方法
- **Ruby中的`nil`是一个对象，表示没有任何东西的对象，而不是没有对象**。nil与nil的比较无论是`==`还是`eql?()`都返回true
- **变量/表达式在字符串中的内插方式是使用`#`开头。在Ruby中，`#`前缀可以看作是一种对某对象的引用、调用之义**。例如：
  - 内插全局变量`#$var`
  - 内插实例变量`#@var`
  - 内插类变量`#@@var`
  - 但是对于普通的不带前缀符号的局部变量或表达式，为了避免歧义，通常在`#`后加上`{}`。例如`#{name}`、`#{3+4}`、`#{func("hello")}`
- **Symbols、numbers、true、false是不可变对象，而字符串、数组、hash是可变对象**，可以使用Object类的`frozen?()`方法判断类型是否可变。如`3.frozen?` 、`[].frozen?`
- **在Ruby中，一元运算符`+= -= *=`等其它类似的操作，和对应的二元运算`x = x + y`是完全等价的，都会创建新的对象x**。其它语言中，可能一元操作符是原处修改的，对应的二元运算是非原处修改的，所以其它语言中使用一元运算方式效率可能会稍高一些，但Ruby中是等价的

- **Ruby中只有nil和false才是布尔假，其它所有都是布尔真**。实际上，nil、false和true分别是NilClass、FalseClass、TrueClass类的实例对象，所有的nil都是同一对象、所有的false也是同一对象，同理所有的true也是同一对象，例如用`nil.equal? nil`比较将得到true
- 更广泛的，**Ruby中所有不可变类型的多个同值对象，都是同一个对象**。例如所有的100数值都是同一个对象，所有的nil、false、值相同的Symbol对象也都是同一个对象。这也导致Ruby中不支持`100++`或者`++100`这样的操作，因为这要求在原处把对象100加1变成101
- **关于变量和值的关系**：Ruby中变量只是存于栈空间中一个引用数据对象的指针，其关系是"变量"指向数据。但有些例外，对于不可变的且占用空间小的对象(包括Fixnum、TrueClass、NilClass、FalseClass的对象)，它们比指针大小更小，它们直接存放在变量中，而没有额外使用一个指针指向它们。
- **关于注释**：Ruby中可以使用`#`符号实现单行注释和行尾注释，使用`=begin`和`=end`实现区块注释
- **关于语句终止和续行**：
  - Ruby不强制分号终止一个语句，可以自己识别
  - 但分号可以终止一个语句
  - 如果需要续行，可以在首行尾部加反斜线`\`，也可以在下一行的非空白首字符加上一个点`.`
  - 操作符在行结尾时可以直接实现续行提示

    ```ruby
    puts "hello world"   # 不加分号终止语句
    puts "hello world";  # 加分号终止语句
    puts 3 +             # 操作符在行尾，自动续行
        2
    puts 3 \             # 行尾加反斜线强制续行
        + 2
    puts 3
        .+ 2       # 行首非空白字符为点号，自动续到上一行
    ```

- **关于函数/方法调用省略括号问题：Ruby沿用了Perl的函数调用行为，可以省略括号**。但注意：
  - `f(3+2) + 1`：表示将`3+2`的结果5作为f函数的参数，最后将f的运行结果加上1
  - `f (3+2) + 1`：表示将`(3+2)+1`的结果6作为f函数的参数
  - 所以，尽量开启`ruby -w`选项，它会提示可能引起歧义的地方
  - 在函数参数包含了括号的时候，强烈建议函数使用括号包围整个参数

- **Ruby的编码主要分为两种：内部源编码、外部默认编码**
  - 源编码设置如何读取Ruby脚本中的字符，源编码会影响源代码文件中的字符串的字面常量编码，可在源代码文件头使用`# coding: utf-8`指定
  - 外部默认编码指定从IO流、外部文件等IO读取时的读取编码，可使用`-E --encoding`设置外部默认编码，使用`Encoding.default_external`查看外部编码  

- Ruby可以通过`object_id`方法来查看对象的唯一id。若想查看对象地址，则`OBJ.object_id.to_s(16)`，此法源于Rubinus源码`core/zed.rb`中定义的to_s()，为了看上去更像地址，可加0x前缀：`"0x"<<OBJ.__id__.to_s(16)`。在CRuby中，查看对象地址的方式为`(OBJ.__id__ << 1).to_s(16)`，如：

    ```ruby
    obj = Cls.new
    #=> #<Cls:0x00007fffc99983a8>
    ( obj.__id__ << 1 ).to_s(16)
    #=> "7fffc99983a8"
    ```